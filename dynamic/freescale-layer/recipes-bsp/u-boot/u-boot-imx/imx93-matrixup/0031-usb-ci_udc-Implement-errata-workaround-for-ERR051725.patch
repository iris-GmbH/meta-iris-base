From 96529e2717ac4fe48a8490eff50afa42c353b3b8 Mon Sep 17 00:00:00 2001
From: Erik Schumacher <erik.schumacher@iris-sensing.com>
Date: Thu, 17 Oct 2024 07:35:48 +0000
Subject: [PATCH] usb: ci_udc: Implement errata workaround for ERR051725

On the i.MX93, a software-controlled detach from USB is not always
possible by clearing the RS bit of USBCMD register. The workaround
utilizes the CTRL2 (USBNC) register.

Signed-off-by: Erik Schumacher <erik.schumacher@iris-sensing.com>
---
 drivers/usb/gadget/ci_udc.c | 23 +++++++++++++++++++++++
 drivers/usb/gadget/ci_udc.h | 10 ++++++++++
 2 files changed, 33 insertions(+)

diff --git a/drivers/usb/gadget/ci_udc.c b/drivers/usb/gadget/ci_udc.c
index bb838b30a4d..71c5e5ddd90 100644
--- a/drivers/usb/gadget/ci_udc.c
+++ b/drivers/usb/gadget/ci_udc.c
@@ -953,10 +953,24 @@ static int ci_pullup(struct usb_gadget *gadget, int is_on)
 {
 	struct ci_udc *udc = (struct ci_udc *)controller.ctrl->hcor;
 	if (is_on) {
+#ifdef CONFIG_IMX93
+		/*
+		 * Workaround for errata ERR051725 of i.MX93
+		 * A simple USBCMD RST is not always enough to trigger a detach event
+		 * on the host, especially with longer USB data lines. Use USBNC CTRL2
+		 * register to detach.
+		 */
+		struct ci_udc_usbnc *usbnc = controller.usbnc_ctrl;
+		setbits_le32(&usbnc->ctrl2, BIT(6));
+#endif
 		/* RESET */
 		writel(USBCMD_ITC(MICRO_8FRAME) | USBCMD_RST, &udc->usbcmd);
 		udelay(200);
 
+#ifdef CONFIG_IMX93
+		setbits_le32(&usbnc->ctrl2, BIT(8));
+#endif
+
 		ci_init_after_reset(controller.ctrl);
 
 		writel((unsigned long)controller.epts, &udc->epinitaddr);
@@ -971,6 +985,12 @@ static int ci_pullup(struct usb_gadget *gadget, int is_on)
 
 		writel(0xffffffff, &udc->epflush);
 
+#ifdef CONFIG_IMX93
+		/* stay in detached state for a bit*/
+		udelay(500);
+		clrbits_le32(&usbnc->ctrl2, BIT(8));
+#endif
+
 		/* Turn on the USB connection by enabling the pullup resistor */
 		setbits_le32(&udc->usbcmd, USBCMD_ITC(MICRO_8FRAME) |
 			     USBCMD_RUN);
@@ -1496,6 +1516,9 @@ static int ci_udc_otg_probe(struct udevice *dev)
 	priv->ctrl.hcor = (struct ehci_hcor *)((ulong)priv->ctrl.hccr +
 			HC_LENGTH(ehci_readl(&(priv->ctrl.hccr)->cr_capbase)));
 	controller.ctrl = &priv->ctrl;
+#ifdef CONFIG_IMX93
+	controller.usbnc_ctrl = (struct ci_udc_usbnc *) priv->phy_data.misc_addr;
+#endif
 
 	ret = ci_udc_probe();
 	if (ret) {
diff --git a/drivers/usb/gadget/ci_udc.h b/drivers/usb/gadget/ci_udc.h
index bea2f9f3fe3..3e15259b1c6 100644
--- a/drivers/usb/gadget/ci_udc.h
+++ b/drivers/usb/gadget/ci_udc.h
@@ -8,6 +8,13 @@
 
 #define NUM_ENDPOINTS		6
 
+#ifdef CONFIG_IMX93
+struct ci_udc_usbnc {
+	u32 ctrl1;		/* 0x00 */
+	u32 ctrl2;		/* 0x04 */
+};
+#endif
+
 #ifdef CONFIG_CI_UDC_HAS_HOSTPC
 struct ci_udc {
 	u32 usbcmd;		/* 0x130 */
@@ -105,6 +112,9 @@ struct ci_drv {
 	struct ept_queue_head		*epts;
 	uint8_t				*items_mem;
 	struct ci_ep			ep[NUM_ENDPOINTS];
+#ifdef CONFIG_IMX93
+	struct ci_udc_usbnc *usbnc_ctrl;
+#endif
 };
 
 struct ept_queue_head {
-- 
2.46.0

