From 5296d3d049fc820135fa17c63705b7e48e29e0a9 Mon Sep 17 00:00:00 2001
From: Erik Schumacher <erik.schumacher@iris-sensing.com>
Date: Thu, 17 Oct 2024 15:19:09 +0000
Subject: [PATCH] net: dp83822: Add dt option to force phy into slave mode

If the DP8382X PHY cannot be configured as a slave by using the strap
pins (which would be the preferred way), one can use the RCSR register
to force the PHY into slave mode.
This introduces a new device tree option that is evaluated by the (new)
probe function for the dp8382x devices.

Signed-off-by: Erik Schumacher <erik.schumacher@iris-sensing.com>
---
 .../boot/dts/freescale/imx93-matrixup.dts     |  2 +-
 drivers/net/phy/dp83822.c                     | 46 +++++++++++++++++++
 2 files changed, 47 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/freescale/imx93-matrixup.dts b/arch/arm64/boot/dts/freescale/imx93-matrixup.dts
index 91b5e52713d7b..a7fa24c505862 100644
--- a/arch/arm64/boot/dts/freescale/imx93-matrixup.dts
+++ b/arch/arm64/boot/dts/freescale/imx93-matrixup.dts
@@ -147,7 +147,7 @@ ethphy1: ethernet-phy@0 {
 			reset-gpios = <&gpio3 21 GPIO_ACTIVE_LOW>;
 			reset-assert-us = <10000>;
 			reset-deassert-us = <80000>;
-			realtek,clkout-disable;
+			ti,force-rmii-slave;
 		};
 	};
 };
diff --git a/drivers/net/phy/dp83822.c b/drivers/net/phy/dp83822.c
index 29e1cbea6dc0c..9c09b805d7246 100644
--- a/drivers/net/phy/dp83822.c
+++ b/drivers/net/phy/dp83822.c
@@ -95,6 +95,7 @@
 #define DP83822_WOL_CLR_INDICATION BIT(11)
 
 /* RCSR bits */
+#define DP83822_RMII_SET_SLAVE	BIT(7)
 #define DP83822_RGMII_MODE_EN	BIT(9)
 #define DP83822_RX_CLK_SHIFT	BIT(12)
 #define DP83822_TX_CLK_SHIFT	BIT(11)
@@ -116,6 +117,7 @@
 
 struct dp83822_private {
 	bool fx_signal_det_low;
+	bool force_rmii_slave;
 	int fx_enabled;
 	u16 fx_sd_enable;
 };
@@ -479,6 +481,17 @@ static int dp83822_config_init(struct phy_device *phydev)
 
 static int dp8382x_config_init(struct phy_device *phydev)
 {
+	struct dp83822_private *dp83822 = phydev->priv;
+	int err;
+
+	if (dp83822->force_rmii_slave) {
+		err = phy_set_bits_mmd(phydev, DP83822_DEVADDR,
+			MII_DP83822_RCSR, DP83822_RMII_SET_SLAVE);
+
+		if (err)
+			return err;
+	}
+
 	return dp8382x_disable_wol(phydev);
 }
 
@@ -512,11 +525,27 @@ static int dp83822_of_init(struct phy_device *phydev)
 
 	return 0;
 }
+
+static int dp8382x_of_init(struct phy_device *phydev)
+{
+	struct dp83822_private *dp83822 = phydev->priv;
+	struct device *dev = &phydev->mdio.dev;
+
+	dp83822->force_rmii_slave = device_property_present(dev,
+							      "ti,force-rmii-slave");
+
+	return 0;
+}
 #else
 static int dp83822_of_init(struct phy_device *phydev)
 {
 	return 0;
 }
+
+static int dp8382x_of_init(struct phy_device *phydev)
+{
+	return 0;
+}
 #endif /* CONFIG_OF_MDIO */
 
 static int dp83822_read_straps(struct phy_device *phydev)
@@ -570,6 +599,22 @@ static int dp83822_probe(struct phy_device *phydev)
 	return 0;
 }
 
+static int dp8382x_probe(struct phy_device *phydev)
+{
+	struct dp83822_private *dp83822;
+
+	dp83822 = devm_kzalloc(&phydev->mdio.dev, sizeof(*dp83822),
+			       GFP_KERNEL);
+	if (!dp83822)
+		return -ENOMEM;
+
+	phydev->priv = dp83822;
+
+	dp8382x_of_init(phydev);
+
+	return 0;
+}
+
 static int dp83822_suspend(struct phy_device *phydev)
 {
 	int value;
@@ -618,6 +663,7 @@ static int dp83822_resume(struct phy_device *phydev)
 		PHY_ID_MATCH_MODEL(_id),			\
 		.name		= (_name),			\
 		/* PHY_BASIC_FEATURES */			\
+		.probe          = dp8382x_probe,		\
 		.soft_reset	= dp83822_phy_reset,		\
 		.config_init	= dp8382x_config_init,		\
 		.get_wol = dp83822_get_wol,			\
-- 
2.46.0

